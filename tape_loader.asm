;[Generated by 6510 Dasm v2.1b (c)2004-05 Luigi Di Fraia]

;
;load RAM from a device
;
$F49E  86  C3        STX $C3         ;set destination address from XY
$F4A0  84  C4        STY $C4
$F4A2  6C  30  03    JMP ($0330)     ;load RAM (normally F4A5)

;
;standard load RAM entry
;
$F4A5  85  93        STA $93         ;set load/verify switch to load
$F4A7  A9  00        LDA #$00
$F4A9  85  90        STA $90         ;clear ST
$F4AB  A5  BA        LDA $BA         ;if current device is keyboard (0)
$F4AD  D0  03        BNE $F4B2
$F4AF  4C  13  F7    JMP $F713       ;indicate Illegal Device # Error


$F4B2  C9  03        CMP #$03        ;if current device is the screen
$F4B4  F0  F9        BEQ $F4AF       ;indicate error
$F4B6  90  7B        BCC $F533       ;if not serial bus device
$F4B8  A4  B7        LDY $B7         ;and if no filename,
$F4BA  D0  03        BNE $F4BF
$F4BC  4C  10  F7    JMP $F710       ;indicate File Name Missing Error


$F4BF  A6  B9        LDX $B9         ;move X to secondary address
$F4C1  20  AF  F5    JSR $F5AF       ;handle load messages
$F4C4  A9  60        LDA #$60        ;set current secondary address
$F4C6  85  B9        STA $B9
$F4C8  20  D5  F3    JSR $F3D5       ;perform open of serial bus device
$F4CB  A5  BA        LDA $BA         ;let A = current device
$F4CD  20  09  ED    JSR $ED09       ;send TALK on serial bus
$F4D0  A5  B9        LDA $B9         ;fetch secondary address
$F4D2  20  C7  ED    JSR $EDC7       ;and send on serial bus
$F4D5  20  13  EE    JSR $EE13       ;input a byte on serial bus
$F4D8  85  AE        STA $AE         ;set I/O end address
$F4DA  A5  90        LDA $90
$F4DC  4A            LSR
$F4DD  4A            LSR
$F4DE  B0  50        BCS $F530       ;if ST doesn't indicate a timeout (read)
$F4E0  20  13  EE    JSR $EE13       ;input a byte on serial bus
$F4E3  85  AF        STA $AF         ;set high byte of end address
$F4E5  8A            TXA
$F4E6  D0  08        BNE $F4F0       ;if EOI is not low,
$F4E8  A5  C3        LDA $C3         ;use destination address
$F4EA  85  AE        STA $AE         ;as end address
$F4EC  A5  C4        LDA $C4         ;ditto for high byte
$F4EE  85  AF        STA $AF
$F4F0  20  D2  F5    JSR $F5D2       ;print LOAD or VERIFY
$F4F3  A9  FD        LDA #$FD        ;clear timeout (read) bit
$F4F5  25  90        AND $90         ;in ST
$F4F7  85  90        STA $90
$F4F9  20  E1  FF    JSR $FFE1       ;check for Stop key
$F4FC  D0  03        BNE $F501       ;if depressed
$F4FE  4C  33  F6    JMP $F633       ;abort load


$F501  20  13  EE    JSR $EE13       ;input a byte on serial bus
$F504  AA            TAX
$F505  A5  90        LDA $90         ;if Timeout (read) set in ST
$F507  4A            LSR
$F508  4A            LSR
$F509  B0  E8        BCS $F4F3       ;abort load
$F50B  8A            TXA
$F50C  A4  93        LDY $93         ;if in verify mode
$F50E  F0  0C        BEQ $F51C
$F510  A0  00        LDY #$00
$F512  D1  AE        CMP ($AE),Y     ;compare byte read to memory
$F514  F0  08        BEQ $F51E
$F516  A9  10        LDA #$10
$F518  20  1C  FE    JSR $FE1C       ;and set verify error on mismatch
$F51B  2C            .BYTE $2C       ;skip next instruction
$F51C  91  AE        STA ($AE),Y     ;load byte to memory
$F51E  E6  AE        INC $AE         ;bump load address
$F520  D0  02        BNE $F524
$F522  E6  AF        INC $AF
$F524  24  90        BIT $90         ;if not end of file
$F526  50  CB        BVC $F4F3       ;repeat
$F528  20  EF  ED    JSR $EDEF       ;else send TALK on serial bus
$F52B  20  42  F6    JSR $F642       ;close serial bus
$F52E  90  79        BCC $F5A9       ;and exit
$F530  4C  04  F7    JMP $F704       ;indicate File Not Found Error


$F533  4A            LSR             ;if input device is not 1 (cassette)
$F534  B0  03        BCS $F539
$F536  4C  13  F7    JMP $F713       ;indicate Illegal Device #


$F539  20  D0  F7    JSR $F7D0       ;fetch tape buffer pointer
$F53C  B0  03        BCS $F541
$F53E  4C  13  F7    JMP $F713       ;if invalid, indicate Illegal Device #


$F541  20  17  F8    JSR $F817       ;display msgs and test buttons for read
$F544  B0  68        BCS $F5AE
$F546  20  AF  F5    JSR $F5AF       ;handle load messages
$F549  A5  B7        LDA $B7         ;if file name present
$F54B  F0  09        BEQ $F556
$F54D  20  EA  F7    JSR $F7EA       ;search tape for file name
$F550  90  0B        BCC $F55D       ;if no errors, continue
$F552  F0  5A        BEQ $F5AE       ;exit if end of tape
$F554  B0  DA        BCS $F530       ;error if not found
$F556  20  2C  F7    JSR $F72C       ;since no file name, get next tape hdr
$F559  F0  53        BEQ $F5AE       ;exit if end of tape found
$F55B  B0  D3        BCS $F530       ;indicate File Not found Error
$F55D  A5  90        LDA $90         ;check ST for unrecoverable read error
$F55F  29  10        AND #$10
$F561  38            SEC
$F562  D0  4A        BNE $F5AE       ;and exit if so
$F564  E0  01        CPX #$01        ;if not Program Header
$F566  F0  11        BEQ $F579
$F568  E0  03        CPX #$03
$F56A  D0  DD        BNE $F549
$F56C  A0  01        LDY #$01
$F56E  B1  B2        LDA ($B2),Y
$F570  85  C3        STA $C3         ;reset load address from tape buffer
$F572  C8            INY
$F573  B1  B2        LDA ($B2),Y     ;high byte also
$F575  85  C4        STA $C4
$F577  B0  04        BCS $F57D
$F579  A5  B9        LDA $B9
$F57B  D0  EF        BNE $F56C
$F57D  A0  03        LDY #$03        ;index low byte of end address
$F57F  B1  B2        LDA ($B2),Y
$F581  A0  01        LDY #$01
$F583  F1  B2        SBC ($B2),Y     ;compute length of block to load
$F585  AA            TAX
$F586  A0  04        LDY #$04
$F588  B1  B2        LDA ($B2),Y
$F58A  A0  02        LDY #$02
$F58C  F1  B2        SBC ($B2),Y
$F58E  A8            TAY
$F58F  18            CLC
$F590  8A            TXA
$F591  65  C3        ADC $C3
$F593  85  AE        STA $AE         ;and set the end address of I/O area
$F595  98            TYA
$F596  65  C4        ADC $C4
$F598  85  AF        STA $AF
$F59A  A5  C3        LDA $C3
$F59C  85  C1        STA $C1         ;set tape load address
$F59E  A5  C4        LDA $C4
$F5A0  85  C2        STA $C2
$F5A2  20  D2  F5    JSR $F5D2       ;display load messages
$F5A5  20  4A  F8    JSR $F84A       ;load from cassette
$F5A8  24            .BYTE $24       ;skip next instruction
$F5A9  18            CLC             ;clear error flag
$F5AA  A6  AE        LDX $AE         ;exit with end address in XY
$F5AC  A4  AF        LDY $AF
$F5AE  60            RTS

;---------------------------------

;
;get next file header from cassette
;
$F72C  A5  93        LDA $93         ;save load/verify switch on stack
$F72E  48            PHA
$F72F  20  41  F8    JSR $F841       ;read a block from tape
$F732  68            PLA
$F733  85  93        STA $93         ;restore load/verify flag
$F735  B0  32        BCS $F769       ;exit if read error
$F737  A0  00        LDY #$00
$F739  B1  B2        LDA ($B2),Y     ;get first character in tape buffer
$F73B  C9  05        CMP #$05        ;if code for End of Tape
$F73D  F0  2A        BEQ $F769       ;return
$F73F  C9  01        CMP #$01
$F741  F0  08        BEQ $F74B       ;if not code for Program Header
$F743  C9  03        CMP #$03        ;or "?"
$F745  F0  04        BEQ $F74B
$F747  C9  04        CMP #$04
$F749  D0  E1        BNE $F72C       ;or Data Header, try next block
$F74B  AA            TAX
$F74C  24  9D        BIT $9D         ;if in direct mode,
$F74E  10  17        BPL $F767
$F750  A0  63        LDY #$63        ;point to message FOUND
$F752  20  2F  F1    JSR $F12F       ;and print it
$F755  A0  05        LDY #$05
$F757  B1  B2        LDA ($B2),Y
$F759  20  D2  FF    JSR $FFD2       ;print a file name character
$F75C  C8            INY
$F75D  C0  15        CPY #$15        ;and repeat
$F75F  D0  F6        BNE $F757       ;for all characters
$F761  A5  A1        LDA $A1
$F763  20  E0  E4    JSR $E4E0       ;pause
$F766  EA            NOP             ;filler for patch
$F767  18            CLC
$F768  88            DEY
$F769  60            RTS

;---------------------------------

;
;read a block from cassette
;
$F841  A9  00        LDA #$00
$F843  85  90        STA $90         ;clear ST
$F845  85  93        STA $93         ;set load/verify switch to load
$F847  20  D7  F7    JSR $F7D7       ;set tape buffer to I/O area
$F84A  20  17  F8    JSR $F817       ;handle msgs and test sense for read
$F84D  B0  1F        BCS $F86E
$F84F  78            SEI             ;disable IRQ
$F850  A9  00        LDA #$00
$F852  85  AA        STA $AA         ;set gap
$F854  85  B4        STA $B4         ;set no sync estabilished
$F856  85  B0        STA $B0         ;set no special speed correction yet
$F858  85  9E        STA $9E         ;initialize error log index for pass 1
$F85A  85  9F        STA $9F         ;and pass2
$F85C  85  9C        STA $9C         ;set no byte available yet
$F85E  A9  90        LDA #$90        ;set Flag mask
$F860  A2  0E        LDX #$0E        ;index for cassette read IRQ address
$F862  D0  11        BNE $F875       ;JMP

;
;write a block to cassette
;
$F864  20  D7  F7    JSR $F7D7       ;initialize tape buffer pointer
$F867  A9  14        LDA #$14
$F869  85  AB        STA $AB         ;20 sync patterns
$F86B  20  38  F8    JSR $F838       ;test sense and display msgs for output
$F86E  B0  6C        BCS $F8DC
$F870  78            SEI
$F871  A9  82        LDA #$82        ;mask for ICR1 to honor TB1
$F873  A2  08        LDX #$08        ;IRQ index for cassette write, part 1

;
;common code for cassette read & write
;
$F875  A0  7F        LDY #$7F
$F877  8C  0D  DC    STY $DC0D       ;clear any pending mask in ICR1
$F87A  8D  0D  DC    STA $DC0D       ;then set mask for TB1
$F87D  AD  0E  DC    LDA $DC0E
$F880  09  19        ORA #$19        ;+force load, one shot and TB1 to CRA1
$F882  8D  0F  DC    STA $DC0F       ;to form CRB1
$F885  29  91        AND #$91
$F887  8D  A2  02    STA $02A2       ;and CRB1 activity register
$F88A  20  A4  F0    JSR $F0A4       ;condition flag bit in ICR2
$F88D  AD  11  D0    LDA $D011
$F890  29  EF        AND #$EF
$F892  8D  11  D0    STA $D011       ;disable the screen
$F895  AD  14  03    LDA $0314       ;save standard IRQ vector
$F898  8D  9F  02    STA $029F
$F89B  AD  15  03    LDA $0315
$F89E  8D  A0  02    STA $02A0
$F8A1  20  BD  FC    JSR $FCBD       ;set new IRQ for cassette depending on X
$F8A4  A9  02        LDA #$02
$F8A6  85  BE        STA $BE         ;select phase 2
$F8A8  20  97  FB    JSR $FB97       ;initialize cassette I/O variables
$F8AB  A5  01        LDA $01
$F8AD  29  1F        AND #$1F
$F8AF  85  01        STA $01         ;start cassette motor
$F8B1  85  C0        STA $C0         ;set tape motor interlock
$F8B3  A2  FF        LDX #$FF
$F8B5  A0  FF        LDY #$FF
$F8B7  88            DEY
$F8B8  D0  FD        BNE $F8B7       ;delay 0.3 seconds
$F8BA  CA            DEX
$F8BB  D0  F8        BNE $F8B5
$F8BD  58            CLI
$F8BE  AD  A0  02    LDA $02A0       ;test high byte of IRQ save area
$F8C1  CD  15  03    CMP $0315       ;to determine if end of I/O
$F8C4  18            CLC
$F8C5  F0  15        BEQ $F8DC       ;exit if so
$F8C7  20  D0  F8    JSR $F8D0       ;else test Stop key
$F8CA  20  BC  F6    JSR $F6BC       ;scan keyboard
$F8CD  4C  BE  F8    JMP $F8BE       ;repeat

;---------------------------------

; new tape byte setup

$FB97 A9 08    LDA #$08        eight bits to do
$FB99 85 A3    STA $A3         set bit count
$FB9B A9 00    LDA #$00        clear A
$FB9D 85 A4    STA $A4         clear tape bit cycle phase
$FB9F 85 A8    STA $A8         clear start bit first cycle done flag
$FBA1 85 9B    STA $9B         clear byte parity
$FBA3 85 A9    STA $A9         clear start bit check flag, set no start bit yet
$FBA5 60       RTS

;---------------------------------

; set tape vector

$FCBD BD 93 FD LDA $FD93,X     get tape IRQ vector low byte
$FCC0 8D 14 03 STA $0314       set IRQ vector low byte
$FCC3 BD 94 FD LDA $FD94,X     get tape IRQ vector high byte
$FCC6 8D 15 03 STA $0315       set IRQ vector high byte
$FCC9 60       RTS


;---------------------------------

;
;set IRQ vector depending upon X
;
$FCDB  BD  93  FD    LDA $FD9B-8,X   ;move low byte of address
$FCDE  8D  14  03    STA $0314       ;into low byte of IRQ vector
$FCE1  BD  94  FD    LDA $FD9B-7,X   ;then do high byte
$FCE4  8D  15  03    STA $0315
$FCE7  60            RTS

;---------------------------------

;
;IRQ vectors
; see route @ $FCDB that sets IRQ vector depending on X register

$FD9B .WORD $FC6A ; X = $08 write tape leader IRQ routine
$FD9D .WORD $FBCD ; X = $0A tape write IRQ routine
$FD9F .WORD $EA31 ; X = $0C normal IRQ vector
$FDA1 .WORD $F92C ; X = $0E read tape bits IRQ routine

;======================================
;   cassette read bits IRQ routine
;======================================
;
; current bit count - $A3
; bytes available - $9C
; current bit value - $D7 (0 or 1)
; current byte - $BF
; cycle/phase in current pair (either 0 or 1 ) - $A4

$F92C  AE  07  DC    LDX $DC07       ; X = TBH1
$F92F  A0  FF        LDY #$FF
$F931  98            TYA             ; 
$F932  ED  06  DC    SBC $DC06       ; A = complement of TBL1 (time elapsed)
$F935  EC  07  DC    CPX $DC07       ;if high byte not steady,
$F938  D0  F2        BNE $F92C       ;repeat
$F93A  86  B1        STX $B1         ;else save high byte
$F93C  AA            TAX             ; X = $FF - TBL1
$F93D  8C  06  DC    STY $DC06       ;reset TBL1 to maximum
$F940  8C  07  DC    STY $DC07       ;ditto TBH1
$F943  A9  19        LDA #$19        ;force load, one-shot and Timer B
$F945  8D  0F  DC    STA $DC0F       ;into CRB1
$F948  AD  0D  DC    LDA $DC0D
$F94B  8D  A3  02    STA $02A3       ;save ICR1
$F94E  98            TYA             ; A = $FF
$F94F  E5  B1        SBC $B1         ; A = $FF - TBH1 (complement high byte)
$F951  86  B1        STX $B1         ; $B1 = $FF - TBL1 (save low byte)
$F953  4A            LSR             ; elapsed time HI /= 2 
$F954  66  B1        ROR $B1         ; elapsed time LO /= 2
$F956  4A            LSR             ; elapsed time HI /= 2
$F957  66  B1        ROR $B1         ; elapsed time LO /= 2
$F959  A5  B0        LDA $B0         ; get speed correction
$F95B  18            CLC
$F95C  69  3C        ADC #$3C        ;+240 microseconds
$F95E  C5  B1        CMP $B1         ;if cycle shorter
$F960  B0  4A        BCS $F9AC       ;dismiss
$F962  A6  9C        LDX $9C         ;if byte available
$F964  F0  03        BEQ $F969
$F966  4C  60  FA    JMP $FA60       ;receive it


$F969  A6  A3        LDX $A3         ;test bit count and if beyond last bit,
$F96B  30  1B        BMI $F988       ;do end of byte
$F96D  A2  00        LDX #$00        ;assume bit value of 0
$F96F  69  30        ADC #$30        ;add 432 microseconds
$F971  65  B0        ADC $B0         ;+ 2 * speed correction
$F973  C5  B1        CMP $B1         ;if cycle shorter
$F975  B0  1C        BCS $F993       ;record a 0
$F977  E8            INX             ; X = 1 ===> assume bit value of 1
$F978  69  26        ADC #$26        ;get 584 microseconds
$F97A  65  B0        ADC $B0         ;+ 3 * speed correction
$F97C  C5  B1        CMP $B1         ;if cycle shorter
$F97E  B0  17        BCS $F997       ;record a 1
$F980  69  2C        ADC #$2C        ;get 760 microseconds
$F982  65  B0        ADC $B0         ;+ 4 * speed correction
$F984  C5  B1        CMP $B1         ;if cycle shorter
$F986  90  03        BCC $F98B
$F988  4C  10  FA    JMP $FA10       ;go do end of byte


$F98B  A5  B4        LDA $B4         ;if sync estabilished
$F98D  F0  1D        BEQ $F9AC
$F98F  85  A8        STA $A8         ;set erroneous bits
$F991  D0  19        BNE $F9AC

; record a zero-bit
$F993  E6  A9        INC $A9         ;for a 0, increment 0/1 balance
$F995  B0  02        BCS $F999

; record a one-bit
$F997  C6  A9        DEC $A9         ;for a 1, decrement 0/1 balance

$F999  38            SEC
$F99A  E9  13        SBC #$13        ;0/1 cutoff level
$F99C  E5  B1        SBC $B1         ;-cycle width
$F99E  65  92        ADC $92
$F9A0  85  92        STA $92         ;accumulated for speed correction

; flip cycle in indication
$F9A2  A5  A4        LDA $A4
$F9A4  49  01        EOR #$01        ;flip cycle indication
$F9A6  85  A4        STA $A4

$F9A8  F0  2B        BEQ $F9D5       ;- ==> second cycle

; first cycle
$F9AA  86  D7        STX $D7         ;save bit value

; called if detected cycle is too short
$F9AC  A5  B4        LDA $B4         ;if no sync yet
$F9AE  F0  22        BEQ $F9D2       ;return from IRQ
$F9B0  AD  A3  02    LDA $02A3       ;if ICR1 mask
$F9B3  29  01        AND #$01
$F9B5  D0  05        BNE $F9BC
$F9B7  AD  A4  02    LDA $02A4       ;and last CRA1 mask shows no TA1 flag
$F9BA  D0  16        BNE $F9D2       ;exit from IRQ
$F9BC  A9  00        LDA #$00
$F9BE  85  A4        STA $A4         ;clear cycle count
$F9C0  8D  A4  02    STA $02A4       ;and last CRA1 mask
$F9C3  A5  A3        LDA $A3         ;if bit count indicated end of byte,
$F9C5  10  30        BPL $F9F7
$F9C7  30  BF        BMI $F988       ;go do end of byte

$F9C9  A2  A6        LDX #$A6
$F9CB  20  E2  F8    JSR $F8E2       ;schedule timer
$F9CE  A5  9B        LDA $9B         ;if parity calculated does not match
$F9D0  D0  B9        BNE $F98B       ;set erroneous bit flag
$F9D2  4C  BC  FE    JMP $FEBC       ;exit from IRQ

; called on second cycle (cycle 1)
$F9D5  A5  92        LDA $92         ;if second cycle
$F9D7  F0  07        BEQ $F9E0       ;check accumulated over/under time
$F9D9  30  03        BMI $F9DE
$F9DB  C6  B0        DEC $B0
$F9DD  2C            .BYTE $2C       ;skip next instruction
$F9DE  E6  B0        INC $E0         ;adapt speed correction accordingly
$F9E0  A9  00        LDA #$00
$F9E2  85  92        STA $92         ;reset accumulated over/under time
$F9E4  E4  D7        CPX $D7         ;if 2nd cycle = complement of cycle 1
$F9E6  D0  0F        BNE $F9F7       ;include bit
$F9E8  8A            TXA
$F9E9  D0  A0        BNE $F98B       ;if two 0 cycles
$F9EB  A5  A9        LDA $A9         ;and 0/1 balance
$F9ED  30  BD        BMI $F9AC
$F9EF  C9  10        CMP #$10        ;at least 16 "0" cycles extra
$F9F1  90  B9        BCC $F9AC
$F9F3  85  96        STA $96         ;set sync detected
$F9F5  B0  B5        BCS $F9AC
$F9F7  8A            TXA
$F9F8  45  9B        EOR $9B         ;calculate parity
$F9FA  85  9B        STA $9B
$F9FC  A5  B4        LDA $B4         ;if no sync yet
$F9FE  F0  D2        BEQ $F9D2       ;exit
$FA00  C6  A3        DEC $A3         ;decrement pending bit count
$FA02  30  C5        BMI $F9C9       ;after last bit, check parity
$FA04  46  D7        LSR $D7         ;move current bit into CARRY flag (logical shift RIGHT , bit 0 shifted into CARRY)
$FA06  66  BF        ROR $BF         ;shift current bit (in carry) into bit 7 of byte being read
$FA08  A2  DA        LDX #$DA
$FA0A  20  E2  F8    JSR $F8E2       ;schedule timer
$FA0D  4C  BC  FE    JMP $FEBC       ;exit from IRQ

; invoked after 8 bits have been received
$FA10  A5  96        LDA $96         ;if sync detected
$FA12  F0  04        BEQ $FA18       ; => No Sync
$FA14  A5  B4        LDA $B4         ;and not yet estabilished
$FA16  F0  07        BEQ $FA1F       ; sync but not established

$FA18  A5  A3        LDA $A3         ;or last bit done
$FA1A  30  03        BMI $FA1F       ; bit count > 8
$FA1C  4C  97  F9    JMP $F997       ; allow byte reception ==> 1-bit detected


$FA1F  46  B1        LSR $B1         ;compute new speed correction value
$FA21  A9  93        LDA #$93
$FA23  38            SEC
$FA24  E5  B1        SBC $B1
$FA26  65  B0        ADC $B0
$FA28  0A            ASL
$FA29  AA            TAX
$FA2A  20  E2  F8    JSR $F8E2       ; schedule timer

$FA2D  E6  9C        INC $9C         ; indicate byte available
$FA2F  A5  B4        LDA $B4         ; if not yet estabilished
$FA31  D0  11        BNE $FA44
$FA33  A5  96        LDA $96         ;but sync detected
$FA35  F0  26        BEQ $FA5D
$FA37  85  A8        STA $A8         ;set error bits
$FA39  A9  00        LDA #$00
$FA3B  85  96        STA $96         ;clear sync detected
$FA3D  A9  81        LDA #$81        ;set TA1 bit
$FA3F  8D  0D  DC    STA $DC0D       ;in ICR1
$FA42  85  B4        STA $B4         ;set sync estabilished
$FA44  A5  96        LDA $96         ;move sync status
$FA46  85  B5        STA $B5         ;to saved sync status
$FA48  F0  09        BEQ $FA53
$FA4A  A9  00        LDA #$00        ;if not detected,
$FA4C  85  B4        STA $B4         ;indicate sync not estabilished
$FA4E  A9  01        LDA #$01
$FA50  8D  0D  DC    STA $DC0D
$FA53  A5  BF        LDA $BF         ;clear TA mask in ICR1
$FA55  85  BD        STA $BD         ;save byte read
$FA57  A5  A8        LDA $A8
$FA59  05  A9        ORA $A9         ;accumulate possible errors
$FA5B  85  B6        STA $B6
$FA5D  4C  BC  FE    JMP $FEBC       ;exit from IRQ

;---------------------------------

;
;schedule CIA1 Timer A depending on parameter in X
;
$F8E2  86  B1        STX $B1         ;save entry parameter
$F8E4  A5  B0        LDA $B0         ;get speed correction
$F8E6  0A            ASL             ;* 2
$F8E7  0A            ASL             ;* 4
$F8E8  18            CLC
$F8E9  65  B0        ADC $B0         ;add speed correction
$F8EB  18            CLC
$F8EC  65  B1        ADC $B1         ;and parameter
$F8EE  85  B1        STA $B1         ;save low order
$F8F0  A9  00        LDA #$00
$F8F2  24  B0        BIT $B0         ;if speed correction is positive
$F8F4  30  01        BMI $F8F7
$F8F6  2A            ROL             ;set high oreder in A
$F8F7  06  B1        ASL $B1         ;* 2
$F8F9  2A            ROL
$F8FA  06  B1        ASL $B1         ;* 4
$F8FC  2A            ROL
$F8FD  AA            TAX
$F8FE  AD  06  DC    LDA $DC06       ;wait until no change of
$F901  C9  16        CMP #$16        ;TBL1 changing
$F903  90  F9        BCC $F8FE       ;while it still must be read
$F905  65  B1        ADC $B1         :add low order offset to TBL1
$F907  8D  04  DC    STA $DC04       ;and store in TAL1
$F90A  8A            TXA
$F90B  6D  07  DC    ADC $DC07       ;add high order offset to TBH1
$F90E  8D  05  DC    STA $DC05       ;and store in TAH1
$F911  AD  A2  02    LDA $02A2
$F914  8D  0E  DC    STA $DC0E       ;set CRA1 from CRB1 activity register
$F917  8D  A4  02    STA $02A4       ;and save it
$F91A  AD  0D  DC    LDA $DC0D
$F91D  29  10        AND #$10
$F91F  F0  09        BEQ $F92A       ;if Flag bit is not set
$F921  A9  F9        LDA #$F9        ;set exit address on stack
$F923  48            PHA
$F924  A9  2A        LDA #$2A
$F926  48            PHA
$F927  4C  43  FF    JMP $FF43       ;and simulate an IRQ


$F92A  58            CLI             ;else allow IRQ and exit
$F92B  60            RTS